## Redis的一些常见问题

最重要的一点： Redis 是**单线程**的**！！！！**

- 但是为什么运算速度那么快？因为所有的运算都是**内存级别的运算**



- 为什么 Redis 是单线程的。但是它却能够并发地处理多个客户端

  多路复用【还有疑惑！！！！！】



非阻塞IO

读取套接字

首先介绍下阻塞IO：read方法会传递进去参数n，表示最多读取n个字节就返回

如果一个字节都没有的话，线程就会阻塞在那里。一直等待新的数据到来或者

连接关闭。read方法才返回，线程才能继续执行

**非阻塞IO：在套接字对象上提供了个选项 non-blocking 读写方法不会阻塞**

能读多少就读多少：**取决于内核为套接字分配的读缓冲区内部的数据字节数**

**能写多少就写多少：取决于内核为套接字分配的写缓冲区的空间空闲字节数**

读写方法都会通过返回值告知程序实际读写了多少字节

————————————首先了解下事件轮询————————————

输入是读写描述符列表 read_fds & write_fds

输出是与之对应的可读可写事件

同时提供了一个timeout参数



在没有任何时间到来的时候，等待timeout时间（线程处于blocking阻塞状态）

一旦在这期间有事件来临，就马上返回

等到timeout时间过了也没有时间来临，也马上返回

在线程拿到事件之后，就开始处理事件。处理完事件后，又过来轮询



就这样成为一个死循环——这个死循环就是事件轮询

——————————————————————————————————

当我们通过 select 系统调用同时处理多个通道描述符（？？？？）的读写事件

因此我们将这类系统调用成为多路复用API



指令队列：

Redis会**为每个客户端套接字关联一个指令队列**。客户端的指令通过队列来进行顺序执行

响应队列：

Redis会为每个客户端套接字关联一个响应队列。Redis通过响应队列来将指令的返回结果回复给客户端。如果队列为空，就将客户端描述符从write_fds里移出来，不去获取写事件。等有数据了再放进去。

这样会减少CPU性能消耗（因为上面的【等到timeout时间过了也没有时间来临，也马上返回】，结果发现无数据可写）

定时任务：

Redis除了响应I/O 还要处理定时任务

这里所说的定时任务或者说计划任务并不是很多人想象中的那样，比如说每天凌晨三点自动运行起来跑一个脚本。这种都已经烂大街了，随便一个 [Cron](https://www.baidu.com/s?wd=Cron&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)tab 就能搞定了。

​       **这里所说的定时任务可以说是[计时器](https://www.baidu.com/s?wd=计时器&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)任务，比如说用户触发了某个动作，那么从这个点开始过二十四小时我们要对这个动作做点什么。那么如果有 1000 个用户触发了这个动作，就会有 1000 个定时任务。于是这就不是 Cron 范畴里面的内容了。**

这里Redis用到了最小堆，将所有的定时任务排序。获得最小的timeout就是Redis可以休眠的事件。在这个timeout事件里面Redis可以安心的睡眠。不需要处理任何定时任务